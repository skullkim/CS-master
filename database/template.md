# ACID
- Atomic(원자성) : 전부 반영되거나 전부 반영되지 않아야한다는 성질
- Consistency(일관성) : 트랜잭션 실행 이전과 이후가 항상 동일한 상태로 안정되야 한다는 성질(테이블의 제약조건 등이 바뀌면 안됨)
- Isolatioon(고립성) : 각 트랜잭션이 서로 고립되게 실행되고 영향을 주면 안된다는 성질
- Duratbility(지속성) : 한번 수행된 트랜잭션은 영속적로 반영되어야 한다는 성질

# 정규화, 비정규화
### 정규화

데이터 베이스의 일관성, 유연성을 확보하기 위한 목적으로 데이터를 분해하는 과정을 말함.

- 불필요하거나 중복되는 데이터들을 제거함.
- 이상현상을 방지함.

### 정규화 절차

- 제 1정규화 : 속성의 원자성을 확보하고 원자값이 아닌 도메인을 분해함.
- 제 2정규화 : 기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성을 제거함.(기본키 하나로 데이터가 구분되는 경우 테이블을 나눠야함)
- 제 3정규화 : 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는것을 의미함. (예를들어, A → B → C로 종속적일때, A→B, B→C로 테블을 분해해야함)

### 비정규화

정규화된 데이터 베이스를 시스템의 성능 향상과 운영의 단수화를 위해 데이터를 중복 통합, 분리 등을 수행하는 과정을 말함.

### 비정규화 장단점

장점: 성능 향상과 관리의 효율성이 증가 (테이블 Join등이 줄어들어 조회성능이 향상 됨)

단점: 데이터 일관성, 정합성 저하시킴 & 저장/유지를 위한 별도 비용이 발생 할 수 있음(정규화를 반하기 때문)

### 💡비정규화 대상 예시

*예를 들어, Orders와 Products라는 테이블로 이루어진 정규화된 데이터베이스를 생각해 보자. Orders 테이블에는 productlD를 둘 수는 있어도, productName이라는 필드를 두지는 않을 것이다. 따라서 주문 정보와 상품 이름을 함께 나열하고 싶은 경우에는 두 테이블을 조인해야 한다.*

*어떤 면에서는 멋진 방법이다. 상품이 자신의 이름을 바꿀 경우, 한 곳의 데이터만 갱신하면 된다.*

*하지만 이 방법의 단점은 테이블이 아주 클 경우 조인을 하느라 불필요할 정도로 많은 시간을 낭비하게 된다는 것이다.*

### 비정규화 대상

1. 자주 사용되는 테이블에 조회 쿼리가 많은 경우
2. 테이블에 대량 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 이슈가 있을 경우
3. 테이블에 지나치게 많은 조인을 사용하게 되어 데이터 조회하는 것이 어려운 경우



# join 작동 방식
# inner join, outer join
- InnerJoin : 두 테이블을 조인할 때, 두 테이블에 모두 지정한 열의 데이터가 있어야함.
- OuterJoin :  두 테이블을 조인할 때, 1개의 테이블에만 데이터가 있어도 결과가 나옴(반대쪽 테이블의 칼럼을 null로 채움).
    - LEFT OUTER JOIN: 왼쪽 테이블의 모든 값이 출력되는 조인
    - RIGHT OUTER JOIN: 오른쪽 테이블의 모든 값이 출력되는 조인
    - FULL OUTER JOIN: 왼쪽 또는 오른쪽 테이블의 모든 값이 출력되는 조인
    
# ORM이란
ObjectRelationalMapping의 약자이다. 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다.

💡객체와 테이블의 차이

각 테이블은 양방향 참조를 할 수 있다. 예를 들어, 주문 테이블에 상품 정보가 저장되어있으면, 주문 → 상품 조회가 가능하고 상품 → 주문 조회가 가능하다. 하지만 객체는 일반적으로 단방향 참조를 한다. 주문 → 상품의 참조 관계라면 상품이 주문에 접근 할 수 없다. 이러한 객체와 DB 테이블 간의 간극을 맺어주는것이 ORM이다.


# SQL, NoSQL


# drop, truncate, delete의 차이점을 설명해주세요
- drop 명령어 : DB 테이블 정의 및 해당 테이블에 대한 모든 데이터, 인덱스, 권한을 제거함. 모두 제거하기에 RollBack이 불가능하다.
- delete 명령어 : 테이블 내부의 행을 모두 삭제하며, WHERER 절을 상요하여 개별적으로 행을 삭제할 수 있음.
- truncate 명렁어 : DB 테이블 내부의 모든 행을 삭제함. 권한, 인덱스 등을 제거하지 않고 행만을 삭제함.


# query 수행 순서
- **FROM** : 각 테이블 확인
- **ON** : 조인 조건 확인
- **JOIN** : 테이블 조인 (병합)
- **WHERE** : 데이터 추출 조건 확인
- **GROUP BY** : 특정 칼럼으로 데이터 그룹화
- **HAVING** : 그룹화 이후 데이터 추출 조건 확인
- **SELECT** : 데이터 추출
- **DISTINCT** : 중복 제거
- **ORDER BY** : 데이터 정렬

💡 LIMIT 쿼리

LIMIT 쿼리는 ORDER BY 이후에 실행됨.

💡 WHERE과 ON의 차이점 

WHERE과 ON 모두 Join시에 데이터를 비교하는 연산자이다. 하지만 ON은 Join전에 조건을 필터링 하고 WHERE은 Join 후에 조건을 필터링 한다.

InnerJoin을 하는 경우, 두 조건문은 차이점을 가지지 않는다. 하지만 OuterJoin을 수행하게 되면 두가지 조건문은 큰차이를 가진다. 

OuterJoin은 조건문과 일치하는 데이터가 없으면 null로 값을 채워 레코드를 생성한다. 그래서 ON 조건과 일치하는 데이터가 없는 경우 결과 테이블에는 null로 값이 채워지게 된다. 

하지만 WHERE은 JOIN 수행 후의 레코드에 대해 비교조건을 수행한다. 그래서 비교조건과 일치하는 레코드가 없으면(null인 경우) 해당 레코드를 결과 테이블에서 제거한다.
# connection pool
어플리케이션에서 DB에 데이터를 저장하려고 하면 DB Connection을 생성해야한다. 아래의 과정이 수행된다.

![image](https://user-images.githubusercontent.com/71062817/236664809-aae17cea-5b11-481e-8cfb-deecce771578.png)


위 과정의 3~6번도 번거롭지만 2번 과정에서는 TCP/IP 통신이 발생한다. 그래서 네트워크 통신 비용이 발생하고 성능저하의 원인이 될 수 있다. 클라이언트가 요청에 대한 응답을 받을 때, 어플리케이션과 DB 통신시간이 포함되기 때문이다.

그래서 DB ConnectionPool 이라는 바구니에 Connection 정보를 미리 담아두고 이를 통해 어플리케이션과 DB가 통신을 하도록 하는 것을 ConnectionPool이라고 한다.

![image](https://user-images.githubusercontent.com/71062817/236664815-5dc341ce-9a47-4b14-9228-d6c8785d37f6.png)


ConnectionPool은 설정에 따라 어플리케이션 초기화와 함께 DBConnection을 생성하고 담아두거나 일정 시간마다 DBConnection을 관리해준다. 그리고 TCP/IP의 통신 연결및 종료 과정을 생략하므로 성능상의 이점이 있다.

### ConnectionPool 크기

그렇다면 ConnectionPool을 크게 가져가면 성능이 무조건 좋아질까? 아니다. ConnectionPool은 DB의 하드웨어 성능을 고려하여 설정하는 것이 좋다. 왜냐하면 ConnectionPool에 담긴 커넥션이 100개 이고 100개의 요청에 모두 DBConnection을 할당 해주어도 DB 서버의 CPU core가 한개라면 요청 처리를 위해 99개의 커넥션은 대기해야하기 때문이다. 이때, 컨텍스트 스위칭 비용이 커지고 병목이 발생한다.

Spring은 기본 제공하는 DB ConnectionPool에서 *아래와 같은 공식을 제공한다.*

```java
DB 서버의 CPU core * 2 + HDD SPINDLE 개수
```

# 트랜젹션

DB관점에서 트랜잭션은 데이터를 CRUD하는 작업의 최소단위이다. 트랜잭션을 통해 데이터를 적재하거나 가공하는 작업을 처리 할 수 있다.

Application 관점에서는 논리적으로 API 처리하는 작업을 의미한다. 이때, 동시에 여러 트랜잭션이 발생하고 임계영역에 대한 경쟁조건으로 동시성 이슈가 발생 할 수 있다.

트랜잭션은 맨 처음과 같이 데이터 적재에 대한 ACID 조건을 달성해야한다. 가장중요한 조건은 I(Isolation)이다. Isolation(독립성)이 잘 이루어지지 않으면 데이터가 의도하지 않게 오염되는 문제가 발생 할 수 있기 때문이다. 

하지만 Isolation(독립성)을 완전하게 수행하려하면 DB 성능에 손해를 가져 올 수 있다. 그래서 성능과 트랜잭션간의 독립성을 고려하여 Isolation 기법이 나누어져 있다. 이때 Isolation 수준에 따라 Read Uncommited, Read Commited, Repeatable Read, Serializable로 나눌 수 있다.


# 낙관적 락, 비관적 락, 분산 락을 설명해주세요
어플리케이션 레벨에서 API의 작업단위에 따라서 트랜잭션을 처리하다보면 임계영역에 대한 경쟁조건이 발생하여 원치 않게 트랜잭션간의 경합이 발생하는 동시성 이슈가 발생할 수 있다.

이때, 락을 통해 여러 트랜잭션(쓰레드간의 작업)끼리의 임계영역에 대한 동시성 이슈를 해결하는 기법들을 낙관적 락, 비관적 락, 분산 락이라고 한다. 각 기법은 서로 다른 방법으로 동시성 이슈를 해결하고 각각의 장단점을 가진다.

**1️⃣ 낙관적 락**

**동시성 이슈가 거의 발생 하지 않을 것으로 가정**하고 동시성 이슈를 해결하는 기법이다. 낙관적락은 DB에 물리적인 Lock을 걸지 않고 Version 칼럼을 통해 논리적으로 락을 걸어 동시성 이슈를 해결한다.

예시와 함께 천천히 살펴보자. 만약 어떠한 API 기능이 다음과 같은 작업을 처리한다고 가정하자.

1) 자신의 접근권한이 ADMIN인지 확인한다.

2) ADMIN 권한이 맞다면 자신의 권한을 NONE으로 변경하고 보유금액을 1000원 차감한다.

로직이 이상하지만 위와 같은 경우에 동시성 이슈가 발생 할 수 있다. 아래 그림을 살펴보자.

![1](https://github.com/gudonghee2000/CS-master/assets/71062817/8f2e5665-6328-4d62-a389-9ae1032e7016)


위 그림은 API 기능을 두가지 쓰레드에서 동시에 발생 했을 경우를 보여준다. 논리적으로는 TX1에서 접근 권한을 NONE으로 변경하고 보유금액을 1000원 차감 했기 때문에 TX2는 실패해야 할 것 같다.

 

하지만 실제로는 TX2로 인해 보유금액이 1000원이 추가로 차감 될 수 있다. 왜냐하면 TX2가 DB에서 접근 권한이 ADMIN인지 확인 할 때에는 TX1의 권한 변경(ADMIN → NONE)이 적용되지 않았기 때문이다.

낙관적락으로 위와 같은 상황을 해결 할 수 있다. 아래 사진을 살펴보자.

![2](https://github.com/gudonghee2000/CS-master/assets/71062817/7251c00a-de3a-44f0-a193-ac134f547f00)


낙관적락은 위와 같이 실제 DB Table에 Version칼럼을 추가한다. 그리고 해당 레코드가 변경 될 때마다 Version 칼럼을 증가시킨다. 

이전 사진과 거의 동일하지만 TX1이 회원의 권한을 NONE으로 변경하고 보유금을 차감 할 때 VERSION 칼럼이 2로 바뀐다. 그리고 TX2가 동일한 쿼리를 수행 할 때, VERSION칼럼을 비교한다. 

하지만 TX2가 권한을 확인했을때는 VERSION 레코드가 1이고 TX1이 UPDATE를 수행하여 실제 DB Table 레코드는 VERSION 칼럼이 2가 되었다. 그래서 VERSION 칼럼의 불일치가 발생하고 TX2는 실패하게 된다. 

이러한 방법으로 동시성 이슈를 해결 할 수 있다. Spring Data JPA에서는 손쉽게 낙관적락을 적용하는 애노테이션들을 제공한다. 그리고 위와 같은 방법으로 해결되지 않는 동시성이슈가 있으며 이를 해결하기 위한 낙관적락 기법 또한 다양하다.

 

**2️⃣ 비관적 락**

동시성 이슈가 많이 발생할 것으로 예상하고 DB에 물리적인 락을 걸어 동시성 이슈를 해결하는 기법이다. 이때, 락을 걸면 무조건 트랜잭션이 완료될 때 까지 대기하게 된다. 

비관적락은 DB에 물리적인 락을 적용하는 기법이다. 그리고 물리적인 락에는 공유락과 베타락이 있으며 두 기법적용에 따라 동시성 이슈가 해결 될 수도 있고 되지 않을 수 도 있다.

**3️⃣ 분산락**

여러 어플리케이션 서버에서 발생하는 동시성 이슈를 해결하기 위한 락 기법이다. DB에서 발행하는 락을 어플리케이션이 취득하고 임계영역에 대한 작업을 처리하는 기법이다. 어플리케이션이 락을 취득하는 동안 다른 어플리케이션 서버 또는 동일한 서버의 쓰레드들이 임계영역에 접근하지 못하고 대기한다는 특징이 있다.

이때 주요한 특징은 여러 어플리케이션 서버에서 사용한다는 점이다. 여러 서버들이 사용하기위해 락을 발행하는 주체는 DB가 된다. Mysql은 네임드락이라는 이름을 가진 락을 발행하는 기법으로 분산락을 제공한다. 이를 통해 여러 어플리케이션 서버들의 임계영역에 대한 경쟁조건을 방지 할 수 있다.

## 분산락 vs 낙관적락 & 비관적락

언뜻보기에 분산락을 통해 동시성 이슈를 해결하는 것이 임계영역에 대한 접근을 아예 막아버리기 떄문에 낙관적락과 비관적락에 비해 성능이 좋지 않을 것 같다. 

하지만 분산락은 좀 더 다른 특징을 가진다. **예를들어 회원이 DB에 저장한 사과의 개수가 30개가 되도록 하고 싶다고 하자.** 

이때 낙관적락과 비관적락은 임계영역(사과 개수 최대 30개)에 대한 접근을 차단하지는 않기 때문에 동시에 여러 트랜잭션을 처리하는 과정에서 DB에 저장한 사과의 개수가 30개가 넘을 수 도 있다.

반면, 분산락은 임계영역에 대한 접근 자체를 차단하기 때문에 회원이 DB에 저장한 사과의 개수가 30개 여야한다는 조건을 만족하기가 쉽다.

이러한 차이로 인해 분산락을 적용하는 것이 더 유효한 경우가 있다.

# mvcc

MVCC는 Mysql InnoDB 엔진에서 Repeatable Read Isolation 수준과 트랜잭션 롤백을 위해 사용하는 동시성 제어 기법이다. 

MVCC는 Undo로그에 현재 트랜잭션의 레벨과 데이터 정보를 기록하고 언제든 롤백을 처리하고 NonRepeatable Read를 방지해준다.

# 인덱스

DB Table에 저장된 레코드 일부를 0 - 100까지 전부 디스크에 접근하여 확인해야한다면 성능이 느려질 것이다.(데이터가 많을수록 더 심함)

그래서 이를 해결하기 위한 기법이 인덱스이다. 인덱스는 백과사전의 ㄱ, ㄴ, ㄷ 과 같은 색인을 떠올리면 쉽다. 우리는 **다음**이라는 글자를 찾기위해 백과사전의 첫페이지부터 읽기 보다 **ㄷ**목록부터 읽어서 찾는 것이 훨씬 빠르다는 것을 알고 있다. 인덱스도 위와 같다.

Mysql의 InnoDB 기준으로 저장되는 PK 값에 따라 클러스터 인덱스가 적용된다. 그리고 클러스터 인덱스 값에 따라서 실제 데이터페이지가 저장되어 있다. 그리고 개발자가 PK를 제외한 특정 칼럼들을 가지고 세컨더리 인덱스를 생성 할 수 있다.

인덱스 사용은 쿼리 실행 전 옵티마이저에 의해 최적화 되는데 이때 사용되는 인덱스 기법들은 아래와 같다.

- 커버링인덱스
- 인덱스 풀 스캔
- 인덱스 레인지 스캔
- 인덱스 스킵 스캔
- 루즈 인덱스 스캔
- 복합 인덱스 스캔

등이 있다. 위와 같은 스캔 기법들은 쿼리 수행 전 옵티마이저에 의해 최적화되어 수행된다. 우리는 EXPLAIN 쿼리를 통해 옵티마이저가 선택한 탐색기법을 확인 할 수 있다.

# Cap 이론

![Untitled](https://github.com/gudonghee2000/CS-master/assets/71062817/8a57e774-ca83-45df-bab7-84758376f20a)

CAP 이론은 시스템은 일관성(Consistency), 가용성(Availablity), 분단 허용성(Partition torlerance) 세 가지 속성 중에서 두가지만 가질수 있다라고 말한다.

일관성(Consistency) : 데이터를 저장하는 장비가 1대 든 100대든 모든 장비에 동일한 데이터가 저장되어 있어야한 다는 것을 의마한다.

가용성(Availablity) : 가용성은 죽지 않은 상태의 모든 서버는 클라이언트에게 항상 정상 응답을 보내주어야한다는 것을 의미한다.

분단 허용성(Partition tolerance) : 클러스터 환경에서, 클러스터 사이에 통신을 할 수 없어도 시스템이 잘 동작해야한다는 것을 의미한다.

# 레디스

서비스가 확장되면 트래픽이 증가하고 수많은 데이터가 DB에 저장되게 된다. 저장된 데이터가 많아질 수록 API 요청에 따라 적절한 데이터를 조회하는 작업처리 시간은 자연스럽게 증가된다.

하지만 고객의 입장에서 API 요청에 따라 적절한 데이터를 받기 까지 지연시간이 길어 질 수록 서비스에 대한 불만이 높아지고 결국에는 서비스를 사용하지 않게 될 수 있다.

이때 조회 성능의 개선을 위한 방법 중 하나는 **캐시(Cache)가 있으며 캐시를 통해 높은 성능 개선을 이뤄 낼 수 있다.** 캐시를 통해서 고객은 DB에 직접 엑세스 하지 않고도 빠르게 데이터를 받고 높은 서비스 응답률을 이뤄 낼 수 있다. 이러한 캐시를 적용하는 오픈소스 프로젝트 중 하나가 레디스이다.

 레디스는 key - Value 형태로 데이터를 저장하는 NoSql 기법으로 동작한다. 그리고 싱글 쓰레드로 작동하기에 분산 서버 환경에서도 동시성이슈가 발생하지 않는다. 우리는 분산 서버 환경에서 API 데이터를 레디스에 캐싱하고 서비스함으로써 높은 서비스 응답률을 이뤄 낼 수 있다.

# uuid vs auto increament

Auto Increament는 Table의 데이터의 PK 값을 1, 2, 3, 4, 5와 같이 정수형으로 나타내는 기법을 의미한다. 그렇기때문에 직관적이다. 데이터가 쌓이는 순서에 따라서 PK 값이 증가하는 것은 자연스럽기 때문이다.

하지만 Auto Increament는 몇가지 단점을 가진다. 

1. 보안에 취약하다.
    
    만약 API 요청이 Auto Increament된 PK 값을 기준으로 작업을 처리한다고 했을때, 악의적인 사용자가 PK값을 정수형으로 넣어 잘못된 작업을 처리 할 수 있다. 왜냐하면 Auto Increament는 PK값을 유추하기가 매우 쉽기 때문이다.
    
2. 데이터 베이스 병합과정에서 충돌이 발생 할 수 있다.
    
    Auto Increament는 각 DB별로 정수형의 PK 식별자 값을 가진다. 그래서 DB를 통합 하는 과정에서 PK값 끼리의 충돌이 발생할 가능성이 높다.
    

반면 UUID는 중복되지 않는 랜덤값을 생성해내기에 위와 같은 문제점을 해결 할 수 있다.

그렇다면 UUID를 통해 PK 값을 설정하는것이 올바를까? 그렇지 않다 UUID를 PK 값으로 설정할 때의 단점이 너무 크기 때문이다.

1. 정렬이 안된다.
    
    UUID는 랜덤 String 값이다. 그래서 Auto Increment와 다르게 UUID로 정렬하는 것은 쉽지 않다.
    
2. 용량이 너무 크다.
    
    UUID는 경우의 수가 정수형 PK에 비해 굉장히 길다. 그래서 DB에 저장할 때 더 많은 용량을 할당 받아야하고 이는 데이터베이스 저장공간의 낭비를 가져온다.

# utf-8 vs mb4

데이터베이스의 charset 설정을 utf8 또는 utf8mb4로 설정 할 수 있다. 결론적으로 utf8로 데이터베이스 설정을 하면 emoji를 저장 할 수 없다. 반면 utf8mb4로 설정하면 emoji를 저장 할 수 있다.

# Datetime vs timestamp
