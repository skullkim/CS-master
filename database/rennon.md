# ACID

* 원자성
  * 트랜잭션에 포함된 모든 작업이 모두 성공(Commit)하거나 실패(Rollback)해야 한다.
* 일관성
  * 트랜잭션을 실행한 전후에는 데이터의 일관성이 손상되지 않아야 한다.
* 격리성
  * 동시에 실행하는 여러 개의 트랜잭션이 서로 영향을 주지 않아야 한다.
* 지속성
  * 커밋이 완료된 트랜잭션은 손상되지 않아야한다.

# 정규화, 비정규화

### 정규화의 목적

* 데이터의 중복을 줄이고, 무결성을 유지하여 DB를 효율적으로 관리
* 이상 현상 방지
* 테이블 구성 논리적, 직관적으로 구성

### 이상 현상

* 삽입 이상 - 원하지 않는 데이터가 삽입되거나, 삽입하는데 자료가 부족해 삽입되지 않는 현상
* 삭제 이상 - 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제되어 원하지 않는 데이터 손실이 발생하는 현상
* 수정(갱신) 이상 - 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 현상

### 제 1 정규화

애트리뷰트의 값은 원자값을 가져야한다.(나눠질 수 없는 단일한 값이어야 한다.)

### 제 2 정규화

모든 비주요 애트리뷰트들이 모든 후보키에 대해서 **완전 함수적 종속**이어야 한다. (부분 함수적 종속 X)

### 제 3 정규화

어떠한 비주요 애트리뷰트도 어떤 후보키에 대해서 **이행적으로 종속되지 않아야** 한다. 이행 함수적 종속이란 `X - >Y`, `Y -> Z`의 경우에 의해서 추론될 수 있는 `X -> Z`의 종속관계를 말한다. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.

### 장점

1. 데이터베이스 변경 시 이상 현상(Anomaly) 제거
2. 데이터베이스 구조 확장 용이

### 단점

테이블의 분해로 테이블간의 JOIN 연산이 많아져 데이터 처리 속도가 느려질 수 있다.

### 반정규화 (비정규화)

* 조회를 하는 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다.

* 반정규화를 과도하게 적용하다 보면 데이터의 무결성이 깨질 수 있다. 또한 입력, 수정, 삭제의 질의문에 대한 응답 시간이 늦어질 수 있다.

# join 작동 방식

### Nested Loop Join

* 이중 For문 구조로 조인을 수행한다.
* 데이터량이 적은 테이블을 driving 테이블로 선정해야 더 빠름.
* 랜덤 액세스를 기반으로하기 때문에 대용량 데이터에는 불리함.
* Outer 테이블에 적절한 index가 생성돼있어야함.
* OLTP성 환경에 적합

### Sort Merge Join

* 이중 For문이지만, join 컬럼 기준으로 sorting 후 join
* join에 적절한 인덱스가 없을 경우 사용
* 대용량 데이터를 join할 때 사용
* 범위의 데이터를 처리할 때 사용

### Hash Join

- Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우
- HASH JOIN은 '=' 비교를 통한 조인에서만 사용될 수 있다. 주로 많은 양의 데이터를 조인해야 하는 경우에 주로 사용된다.
- 한마디로 말하면 Nested Loops가 효율적으로 작동하지 않는 경우의 차선책이 Hash이다.
- 배치에서 사용하면 좋은 방법.

# inner join, outer join

### inner join

교집합, 두 테이블 간의 중복된 값을 보여준다.

### left outer join

왼쪽 테이블 기준으로 조인을 한다. 중복되지 않은 값은 NULL로 채워져 나온다.

### right outer join

오른쪽 테이블 기준으로 조인을 한다. 중복되지 않은 값은 NULL로 채워져 나온다.

### full outer join

합집합, 두 테이블의 모든 데이터가 나온다.

### cross join

왼쪽 테이블과 오른쪽 테이블의 모든 경우의 수를 보여준다.

### self join

자기 자신과 조인을 한다.

# ORM이란

**ORM**은 프로그래밍 언어의 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 도구이다.

### 사용 이유

- 객체지향과 데이터베이스간의 패러다임 불일치
- SQL 작성 시간을 줄이고, 비즈니스 로직에 집중 가능
- 데이터 중심적인 설계가 아닌 객체 지향적인 설계 가능

### 단점

* N+1 문제와 같은 문제를 해결해야한다.

# SQL, NoSQL

### SQL

#### 장점

- 명확하게 정의된 스키마, 데이터 무결성 보장
- 관계는 각 데이터를 중복없이 한번만 저장

#### 단점

- 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함. (나중에 수정하기 힘듬)
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음.

### NoSQL

#### 장점

- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도 빨라짐

#### 단점

- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)

### SQL 데이터베이스 사용이 더 좋을 때

- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우

  > NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적

- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL 데이터베이스 사용이 더 좋을 때

- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우

# drop, truncate, delete의 차이점을 설명해주세요

### drop

* DDL
* 인덱스 및 권한과 같은 테이블 정보를 포함하여 테이블을 제거한다.
* Rollback 불가능

### truncate

* DDL
* 테이블 내부의 모든 행을 제거
  * 트랜잭션 로그에 한번만 기록되므로 delete 보다 빠르다.
* Rollback 불가능
* 테이블이 최초 생성 되었을 때의 storage만 남기고, 나머지는 release

### delete

- DML
- row를 1개씩 제거
- Rollback 가능
- truncate 보다 더 많은 트랜잭션 로그
- 테이블 용량 감소 하지 않음

스프링에서 테스트 격리를 위해 @SQL annotation 사용 시, delete all 을 사용했을 때 pk의 auto increment가 초기화 되지 않아 truncate를 사용.

# query 수행 순서

1. from
2. where
3. group by
4. having
5. select
6. order by
7. limit

# connection pool

WAS에서 DB와 관련된 요청이 올때마다 새로운 Connection을 맺으면, 쿼리 수행 시간 뿐만 아니라 Connection 연결시간 까지 걸리기 때문에 매우 비효율적이다. 따라서 미리 커넥션을 맺어놓고, Connection Pool에 미리 생성해둔다.

`connections = ((core_count) * 2) + effective_spindle_count)`

- core_count는 현재 사용하는 서버 환경에서의 CPU 개수를 의미한다.

  `core_count * 2` 를 하는 이유는 Context Switching 및 Disk I/O와 관련이 있다.

  - Context Switching으로 인한 오버헤드를 고려하더라도 데이터베이스에서 Disk I/O(혹은 DRAM이 처리하는 속도)보다 CPU 속도가 월등히 빠르다.
  - 그러므로, Thread가 Disk와 같은 작업에서 블로킹되는 시간에 다른 Thread의 작업을 처리할 수 있는 여유가 생기고, 여유 정도에 따라 멀티 스레드 작업을 수행할 수 있게 된다. Hikari CP가 제시한 공식에서는 계수를 2로 선정하여 Thread 개수를 지정하였다.

- effective_spindle_count는 기본적으로 DB 서버가 관리할 수 있는 동시 I/O 요청 수이다.

  - 하드 디스크 하나는 spindle 하나를 갖는다.
  - 디스크가 16개 있는 경우, 시스템은 동시에 16개의 I/O 요청을 처리할 수 있다.

# 트랜잭션

데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

### 트랜잭션과 락의 차이는?

트랜잭션은 데이터의 정합성을 보장하기 위한것이고, 락은 동시성을 제어하기 위한 기능이다.

### 트랜잭션을 사용할 때 주의할 점

트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화해야한다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.
